<!-- Quirk on -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="X-UA-Compatible" content="IE=8" >


<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Life after Parsing</TITLE>
<META NAME="keywords" CONTENT="parser, parsing, DMS, domain, symbol table, flow analysis, transformation">
<META NAME="description" CONTENT="Semantic Designs: Life after Parsing">
<meta name="author" content="Semantic Designs, Inc.">
<!--
<link rel="stylesheet" href="/SDprint.css" type="text/css" media="print">
<link rel="stylesheet" href="./BBstyle.css" type="text/css" media="screen">
-->

<link rel="stylesheet" href="/SDstyle.css" type="text/css" media="screen">
<link rel="stylesheet" href="/SDmenustyle.css" type="text/css" media="screen">

<!-- Google Analytics support 2023
     Copy the code below and paste it onto every page of your website.
     Paste this code as high in the <head> of the page as possible: 
-->
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5FVCNRJ3');</script>
<!-- End Google Tag Manager -->

</head>

<script type="text/javascript" src="/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/jquery.masonry.min.js"></script>
<script type="text/javascript" src="/LanguagesAndProducts.js"></script>
<script type="text/javascript" src="/jquery.getUrlParam.js"></script>

<script type="text/javascript">

$(window).load(function () {

	var speed = 1000;

  	$('.posts').masonry({
  	columnWidth: 185,
  	// only apply masonry layout to visible elements
 		itemSelector: '.post-block:not(.invis)',
 		animate: true,
 		animationOptions: {
 	  		duration: speed,
 	  		queue: false }
  		  })

  		   var catClass = '.' + $(document).getUrlParam("class");

  		  	if(catClass=='.cat-all' || catClass=='.null') {
  		  	 // show all hidden boxes
  		  	 $('.posts').children('.invis')
  		  		 .toggleClass('invis').animate({opacity: 1},{ duration: speed });
  		  		 $('.posts').masonry();
  		  	} else {
  		  	 // hide visible boxes
  		  	 $('.posts').children().not(catClass).not('.invis')
  		  		 .toggleClass('invis').animate({opacity: 0},{ duration: speed });
  		  	 // show hidden boxes
  		  	 $('.posts').children(catClass+'.invis')
  		  		 .toggleClass('invis').animate({opacity: 1},{ duration: speed });
  		  		$('.posts').masonry();
  		  	}


 });

  $(document).ready(function(){


 	$("#cats li a").click(function(){
  	 var catClass = '.' + $(this).attr('class');
 	 var speed = 1000;
 	 if(window.location.pathname!= "/index.html") window.location.assign("/index.html" + '?class=' + $(this).attr('class'));
  	 if(catClass=='.cat-all') {
  		 // show all hidden boxes
  		 $('.posts').children('.invis')
  			 .toggleClass('invis').animate({opacity: 1},{ duration: speed });
  	 } else {
  		 // hide visible boxes
  		 $('.posts').children().not(catClass).not('.invis')
  			 .toggleClass('invis').animate({opacity: 0},{ duration: speed });
  		 // show hidden boxes
  		 $('.posts').children(catClass+'.invis')
  			 .toggleClass('invis').animate({opacity: 1},{ duration: speed });
  	 }

  	   $('.posts').masonry();

  	   return false;
   	});

  });

</script>

<body onload="changeListRand(document.forms['drops'].language)">

<!-- Google Analytics support 2023
     ... paste this code immediately after the opening <body> tag: 
-->
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5FVCNRJ3"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<!--<div class="mainpage">-->

 <div id="container">
    <div id="home">
        <div id="header">
          <table id="banner"><tbody>
          <tr>
             <td id="company_name_with_legal_mark_box">
<!--                 <a href="/index.html"><img src="/images/name.png" alt="Semantic Designs (SM)"></a> -->
               <a href="/index.html">
                  <div id="company_name_with_legal_mark">
                    Semantic Designs<sup>SM</sup>
                  </div>
               </a>
             </td>
             <td id="slogan_box" align="right">
                 <table><tbody>
                     <tr><td class="slogan_text" align="center">Automated Tools</td></tr>
                     <tr><td class="slogan_text" align="center">for Software Engineering</td></tr>
                 </tbody></table>
   <!--       The Truth is in the Details&#0153; -->
             </td>
          </tr></tbody>
          </table>
          <p id="succinct_summary">Code Search (Find, Follow), Analysis (Metrics, Static, Dynamic, Bugs) and Change (Modernization, Migration, Generation, Optimization, Rearchitecting)</p>
<!--
          System Analysis, Modification, Translation and Generation</a></h2>
<!--
          <h3>Automated Large-Scale Software System Analysis, Modification, Translation and Generation</h3>
		            <h1><a href="/index.html">Semantic Designs</a></h1>
          <h2><a href="/index.html">The Truth is in the Details</a></h2>


         <h3>Automated Large-Scale Software System Analysis, Modification, Translation and Generation&#0153;</h3>
          <h1><a href="/index.html">Semantic Designs</a></h1>
          <h2><a href="/index.html">The Truf is in the ARF Details&#0153;</a></h2>
-->
        </div>

<ul id="css3menu">
	<li class="topfirst"><a href="/index.html" title="Semantic Designs Home Page"><span>Home</span></a></li>

	<li class="topitem"><a href="/Products/Services" title="Services"><span>Services</span></a>
	<ul>
		<li class="subfirst"><a href="/Products/Services/LegacyMigration.html" title="Automated Migration">Automated Migration &#x25BA;</a>
		    <ul>
			    <li class="subfirst"><a href="/Products/Services/COBOLMigration.html" title="COBOL Migration">COBOL Migration</a></li>
			    <li><a href="/Products/Services/MainframeAssemblerMigration.html" title="HLASM Migration">HLASM Migration</a></li>
			    <li><a href="/Products/Services/PL1Migration.html" title="PL/1 Migration">PL/1 Migration</a></li>
			    <li><a href="/Products/Services/NaturalMigration.html" title="Natural Migration">Natural Migration</a></li>
			    <li><a href="/Products/Services/SASMigration.html" title="SAS Migration">SAS Migration</a></li>
			    <li><a href="/Products/Services/SabreTalkMigration.html" title="SabreTalk Migration">SabreTalk Migration</a></li>
			    <li><a href="/Products/Services/ColdFusionMigration.html" title="ColdFusion Migration">ColdFusion Migration</a></li>
			    <li><a href="/Products/Services/CppMigration.html" title="C/C++ Migration">C/C++ Migration</a></li>
		    </ul>
                </li>
		<li><a href="/Products/DMS/DMSToolkit.html" title="Custom Analysis and Transformation">Custom Analysis and Transformation</a></li>
		<li><a href="/Products/FrontEnds/" title="Custom Development Toolkit">Custom Development Toolkit</a></li>
		<li> <a href="/Products/Services/SoftwareModernization.html" title="Application Modernization">Application Modernization</a></li>
		<li><a href="/Products/Tools.html" title="Software Quality Analysis">Software Quality Analysis</a></li>
		<li><a href="/Products/Understanding/index.html" title="Understanding Software Structure">Understanding Software Structure</a></li>
		<li><a href="/Products/DMS/Refactoring.html" title="Code Refactoring">Code Refactoring</a></li>
		<li><a href="/Products/DMS/DMSToolkit.html" title="DMS Licensing and Training">DMS Licensing and Training</a></li>
	</ul>
	</li>

	<li class="topitem"><a href="/Products" title="Products"><span>Products</span></a>
	<ul>

        	<li class="subfirst"><a href="/Products/DMS/DMSToolkit.html" title="DMS"><span>DMS<sup>&reg;</sup></span></a></li>

                <li><a href="/Products/LanguageTools" title="By Language"><span>By Language &#x25BA;</span></a>
		<ul>
			<li class="subfirst"><a href="/Products/LanguageTools/CTools.html" title="C">C</a></li>
			<li><a href="/Products/LanguageTools/CppTools.html" title="C++">C++</a></li>
			<li><a href="/Products/LanguageTools/JavaTools.html" title="Java">Java</a></li>
			<li><a href="/Products/LanguageTools/COBOLTools.html" title="COBOL">COBOL</a></li>
			<li><a href="/Products/LanguageTools/CSharpTools.html" title="C#/.Net">C#/.Net</a></li>
			<li><a href="/Products/LanguageTools/PHPTools.html" title="PHP">PHP</a></li>
			<li><a href="/Products/LanguageTools/VHDLTools.html" title="VHDL">VHDL</a></li>
			<li><a href="/Products/LanguageTools/VerilogTools.html" title="Verilog">Verilog</a></li>
			<li><a href="/Products/LanguageTools" title="More...">More...</a></li>
		</ul>
                </li>

                <li><a href="/Products/Tools.html" title="By Tool"><span>By Tool &#x25BA;</span></a>
		<ul>
			<li class="subfirst"><a href="/Products/SearchEngine/" title="Search Engine">Search Engine</a></li>
			<li><a href="/Products/Clone/" title="Clone Detection">Clone Detection</a></li>
			<li><a href="/Products/TestCoverage/" title="Test Coverage">Test Coverage</a></li>
			<li><a href="/Products/Formatters/" title="Formatters">Formatters</a></li>
			<li><a href="/Products/Obfuscators/" title="Obfuscators">Obfuscators</a></li>
			<li><a href="/Products/Metrics/index.html" title="Metrics">Metrics</a></li>
			<li><a href="/Products/Profilers/index.html" title="Profilers">Profilers</a></li>
			<li><a href="/Products/SmartDifferencer/" title="Smart Differencer">Smart Differencer</a></li>
			<li><a href="/Products/Tools.html" title="More...">More...</a></li>
		</ul>
		</li>

                <li><a href="/Products/Applications/" title="By Application"><span>By Application &#x25BA;</span></a>
		<ul>
			<li class="subfirst"><a href="/Products/Architecture/HoganSystems.html" title="Hogan Analysis">Hogan (Banking) Analysis</a></li>
			<li><a href="/Products/Applications/MoreEffectiveTesting.html" title="Effective Testing">More Effective Testing</a></li>
			<li><a href="/Products/Applications/PatentInfringement/" title="Patent Infringement">Detecting Infringement</a></li>
			<li><a href="/Products/Applications/Agile/AgileTesting.html" title="Agile Testing">Agile Testing</a></li>
		</ul>
		</li>

		<li><a href="/Purchase/Justifications.html" title="Why Buy">Why Buy</a></li>
		<li><a href="/Purchase" title="Purchase">Prices</a></li>
		<li><a href="/Registration" title="Register">Register</a></li>
		<li><a href="/Products/Downloads.html" title="Downloads">Downloads</a></li>
	</ul>
	</li>

	<li class="topitem"><a href="/Company" title="Company"><span>Company</span></a>
	<ul>
		<li class="subfirst"><a href="/Company" title="About SD">About SD</a></li>
		<li><a href="/SuccessStories/index.html" title="Success Stories">Success Stories</a></li>
		<li><a href="/Announce" title="News and Events">News and Events</a></li>
		<li><a href="/Partners" title="Partners">Partners</a></li>
		<li><a href="/Company/CustomerList.html" title="Customers">Customers</a></li>
		<li><a href="/Careers" title="Careers">Careers</a></li>
		<li><a href="/Company/Publications" title="Papers">Papers</a></li>
		<li><a href="/Company/Visions" title="Visions">Visions</a></li>
	</ul>
	</li>

	<li class="topitem"><a href="/Contact/Support.html" title="Support"><span>Support</span></a>
	<ul>
		<li class="subfirst"><a href="/Contact/Support.html" title="Support Policies">Support Policies</a></li>
		<li><a href="/Registration" title="Register">Register</a></li>
		<li><a href="/Products/Downloads.html" title="Downloads">Downloads</a></li>
	</ul>
	</li>

	<li class="toplast"><a href="/Contact" title="Contact"><span>Contact</span></a></li>
</ul>

        <div id="main">
<!--          <h3>Semantic Designs provides <a href="./Products/DMS/DMSToolkit.html?Home=Main">generalized compiler technology</a> and <a href="./Products/?Home=Main">services</a> across a wide variety of computer languages, application types, and architectures.</h3>
          -->


<h1>Life After Parsing&trade;:<br>Got My Grammar... uh, now what?</h1> 

<P>It is astonishing how often people think that the key to building a tool to process
a computer (or <a href="DomainSpecificLanguage.html?Home=LifeAfterParsing">domain-specific</a>)
language is to <i>get a parser</i>.</P>

<P>Its true... in the same sense that playing poker is all about putting the ante into the pot.
If you believe this, the other poker players <b>are going to eat you alive</b>.  Yes, you
have to ante.  No, that's not where the game is played.</P>

<P>Only the most trivial computer languages are easy to analyze and transform. The compiler community
has been working on this problem for 50 years, and one ignores what they have learned at one's peril.
They tell us following technologies are needed to realistically process computer language(s):
<ul>
<li><i>Lexing and Parsing</i>, ... of course. But there are some
really nasty problems here, including preprocessors.</li>
<li><i>Representation Capture:</i> A way to represent and capture program structure</li>
<li><i>Symbol Tables:</i> A mapping between identifiers used in the program, and their meaning (and scope).</li>
<li><i>Inference Methods:</i> A way to understand the <i>meaning</i> and <i>consequences</i> of the written code:</li>
<ul>
<li><i>Simple Fact Collection:</i> Inferences that are easy to extract from the program structure.</li>
<li><i>Control Flow Analysis:</i> Data about the order in which activities occur in a program.</li>
<li><i>Data Flow Analysis:</i> Data about how information flows from one part of the program to another.</li>
<li><i>Symbolic Reasoning:</i> Method to compute complex consequences of semantics and various information flows.</li>
</ul>
<li><i>Pattern Matching and Transformation Capability:</i> Means to
find program points that look like places of interest, as well as
means to convert one program representation instance into others, to provide optimizations or translation to another representation</li>
<li><i>Pretty-Printing:</i> If the representation is modified, one
needs to be able to regenerate <i>valid</i> source code from it.</li>
<li><i>Multi-module and multi-lingual Integration:</i> Inclusion of other programs in the same or another notation to allow one to process <i>systems</i> of code.</li>
</ul>
</P>

<h1>Parsing and Program Analysis using <i>only</i> Regular Expressions is hopeless</h1>

<P>Many people start by trying to use <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>
to parse source code.  Regular expressions are useful for scanning
many kinds of strings with simple structure,
but cannot handle the <i>nested</i> structures typical of a program. 
This <a href="http://stackoverflow.com/a/1732454/120163">Stack Overflow answer</a>
hints at how badly regexes fail for parsing.
They are simply not an answer for parsing.</P>

<h1>Parsing is hard ... but just a distraction</h1>

<p>Tools like YACC, JavaCC, ANTLR, and variants are all about parsing
and a little bit about AST building. It is a big effort to choose the
"right" (lexer and) parser generator, find/create a grammar, wrestle
into a form acceptable by a parser generator (lookaheads? ambiguities?
context sensitivities?), deciding on how to build a tree, ...  Then
there's the often surprisingly big struggle to make the parser match
what the compilers <i>really</i> accept as opposed to what everbody
knows to be true without any further thought (Hey, C source code
doesn't have any complications, its a simple language, right? Can't be
that hard...oops, what's a
<a href="http://en.wikipedia.org/wiki/Digraphs_and_trigraphs">trigraph</a>?).
Putting together a working parser is enough work so
that people tend to focus on just getting that right, paying zero
attention to what is needed after that. And that makes them lose sight
of the full problem.</a>

<p>But success in parsing and tree building is such a <i>small</i>
part of the problem that a victory really means very little.  Climbing
11,000 feet to the foothills of Everest requires only basic
technology: some camping gear and good hiking boots. Any
determined clod can get this equipment and climb the foothills.
To climb to the peak it is clear that one
needs a completely different set of very sophisticated technology
(oxygen tanks are pretty different than hiking boots) and a much different
climbing process to finish the climb to Everest's peak. 
Those that attempt the remaining climb with just the basic equipment
simply die.  Those that have just a parser never really get a useful tool.
</P>

<P>This insight led us to build the <a href="./DMSToolkit.html?Home=LifeAfterParsing">DMS Software
Reengineering Toolkit</a>, to provide as much as possible of that advanced technology.  Semantic Designs
has spent over 17 years building and enhancing that technology, and proving it
on real languages such as COBOL, Java and C++, so that would-be
tool builders don't have to reinvent the infrastructure, and can get on
with building the tool they really wanted. (We don't expect the enhancement  process to ever really stop or even slow down much).  Along the way, we found that
even the parsing process could be significantly enhanced.</P>

<h1>Climbing Mt. Everest for Tool Builders</h1>

<P>Let us consider these additional mechanisms further. First, what
drives the need for this?  Our programming languages, like our
computers, used to be smaller and simpler: FORTRAN66, COBOL, RPG, BASIC, K&R C, ran
on small machines, and were all written in ASCII text in a small
number of files.  Lots of complications have occured since then:
<ul>
<li>Big, complex languges: C99, Enterprise COBOL, Ada2005, Java7, C#4, C++11, Fortran2005, HTML5 each in a variety of dialects... even C isn't small (check out GCC and Microsoft's variants), and Perl is an amazing mess.  Language committees can't resist adding new goodies; there tends to be a "me too" race (Java and C# seem to co-evolve furiously). And companies providing compilers have a vested interest in adding features to create customer lock-ins.</li>
<li>Values in a wide variety of forms and precision: IEEE Floating
point, decimal numbers, infinite precision rationals, ...</li>
<li>Preprocessors, with include files, macros, and the ability to conditionally include/not include program fragments</li>
<li>Locale-specific character sets, Unicode in several flavors, EBCDIC</li>
<li>Embeddings of language fragments into other languages (JavaScript and PHP in HTML, SQL in COBOL, ...</li>
<li>Generics, reflection, and metaprogramming are used more frequently to consruct software systems</li>
</ul>
</P>

<P>Lets examine the necessary tool-supporting mechanism in a bit more
detail. What are they, and why are they needed?
(This discussion parallels the opening):</P>

<ul>
<li>Lexing and Parsing (still necessary!)
<ul>
<li><i>Lexical Capture:</i> It is classic to perform
<a href="http://en.wikipedia.org/wiki/Lexical_analysis">lexical
analysis</a> of the source code, e.g., to break up the stream of
input characters into <i>tokens</i> that represent the conceptual
elements of a program: identifiers, numbers, keywords, comments,
strings, even whitespace.  That idea still generally holds.  It is
also classic to build a hand-coded lexer or use Flex to accomplish
this, and process the ASCII characters in files that made up all the
languages we knew and loved, and in fact still dominate Western
programming. But for highly evolved legacy languages, and modern
languages, you need to process possibly many character representations
(Katakana in comments in C, anyone?) including Unicode, convert
numbers to floating point without losing precision, capture numbers
with possibly arbitrarily large precision, handle keywords that might
be identifiers (PL/1 is famous: every keyword can be an identifier!),
etc.
<br><br><a href="DMSLexers.html?Home=LifeAfterParsing">DMS provides
libraries and tools to handle all of these
issues</a>. The DMS lexer handles full Unicode, has support for opening nested streams
(to handle include files), etc, and can easily build multi-mode lexers
to handle the different lexing needs in the possibly different parts
of the language.  DMS's lexers also capture comments, which are
extremely useful in program analysis and fundamental for program
transformation; users will reject perfectly transformed code that has
lost their comments.  Similarly, DMS will capture lexical details,
such as radix of numbers and string quote style; programmers reject
modified code in which these are lost or changed, too.
We don't know of other production lexer generators that have any
or even most of these properties out of the box.  (If your foundations
aren't right, how are you going to construct a large building?)
</li>
<br>
<li><i>Parsing:</i> It is surprising that the choice of parser is often
made without regard to the language being parsed, often some parser
generator whose major property is that is convenient to download (e.g, Bison, ANTLR, ...).
If your language requires a lot of lookahead, an LL(1) parser is going
to be a very painful choice; if your language has ambiguities,
a parser generator that can only produce one parse will be trouble
(consider parsing C++).  But when parsing real languages,
it is hard to know what issues the parser faces until you are done
building the parser, because you don't know what the grammar will be
until it can basically parse everything.  And the manuals lie about what is legal.  What this
suggests is you should simply use a very strong parsing technology to
avoid as much of this pain as you can.<br><br>DMS uses a <a
href="http://en.wikipedia.org/wiki/GLR_parser">GLR parser</a>, which
means it handles arbitrary lookahead and ambiguous grammars with
aplomb.  Arbitrary semantic reduction conditions allow DMS parsers
to eliminate many ambiguous choices while parsing, or they can be retained
an eliminated later using semantic information. 
<a href="http:DMSParsers.html?Home=LifeAfterParsing">You write a context-free grammar;
DMS's GLR parser can parse it.</a>
So in general parsing is hard; with DMS, parsing is a lot easier.
<br><br>
DMS parsers can be configured to collect preprocessor definitions and
conditionals without expanding them.  This makes it possible to reason
about the code as seen by the programmer, with all the preprocessor
directives in place.   No other tool known to us can do this.
</li>
</ul>

<li><i>Representation Capture:</i> Real tools require more than just
"parsing"; the structure of the program must be captured to
enable further processing.  Usually an <a
href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract
Syntax Tree</a> (AST) is needed. 
Typical parser generators force the grammar engineer to
specify not only the grammar, but also to explicitly specify how to
procedurally build the AST as well. This essentially (more than)
doubles the work, and it makes
maintaining the grammar hard because any grammar changes require the AST building
code as well.  In contrast,
<a href="DMSParsers?Home=LifeAfterParsing">DMS automatically builds
a syntax tree</a>, either a concrete tree ("CST", mainly for debugging, 
containing all the language tokens), or what amounts to an AST
(for production, in which non-value carrying terminals are eliminated,
useless unary productions are removed, and lists are formed).  Changes
to the grammar automatically cause the C/AST to change
correspondingly.  And the tree is <i>always</i> correct with respect to the grammar.  It includes
precise source line information (file/line/column) as well as comments
passed to it by the lexer, attached to appropriate tree nodes, and
it can include preprocessor directives.
</li>
<br>
<li><i>Symbol Tables:</i> A mapping between identifiers used in the
program, and their meaning (and scope).  It is only the grammar which
is context-free in most programming languages; the meaning of
identifiers is usually context ("scope") and semantics
dependent. Generally
to analyze, reason about, or transform programs one must know each
identifier instance represents, where and how that identifier is
defined.
This is traditionally done with a
<a href="http://en.wikipedia.org/wiki/Symbol_table">symbol table</a>,
that maps code regions to sets of identifiers and their definitions.
For real languages a symbol table is often relatively complex because
different code regions implicitly
designate different sets of identifiers (e.g., local scopes, lexical
scopes, namespaces, parameter names, object slots, etc.). So the
symbol table must model the relationship of the various "scopes" to
enable symbols to be correctly found. Such a symbol table
has to be constructed from the program representation; the grammar
gives no clue about this.
<br><br>
DMS provides <a href="DMSSymbolTables.html?Home=LifeAfterParsing">a symbol table structure</a>
with local mappings ("symbol
spaces") of identifiers to definitions to model scopes.  These provide
multiple inheritance support, and are have proven strong enough to handle C++ and the many
other languages that DMS can presently process.   DMS has a library of
routines for symbol-definition insert and fast hashed symbol lookup
with overload resolution that can automatically navigate the symbol "spaces" and find the proper
definition. DMS provides
means to help build symbol tables (see "attribute grammars", below).
No parser generator system known to us provides symbol table
structure support or help in building symbol
tables; the language engineer typically has to write all of this
machinery herself.
</li>
<br>
<li><i>Inference Methods:</i> A way to understand the <i>meaning</i>
and <i>consequences</i> of the written code, e.g., <a
href="http://en.wikipedia.org/wiki/Program_analysis">program
analysis</a>.  Every program analysis or modification task starts with
understanding the code, which requires collections of various kinds of
facts about the code structures and how code elements interact.
We call such determination of facts "inference".   There are inferences that are easy to extract
from the program structure, e.g., the AST.   One can programmatically
traverse an AST with recursive function calls, and almost any parser
generator will provide programmatic access to the nodes in an AST,
but this is inconvenient for a large or complex grammar.  DMS of
course provides such programmatic access, but more importantly
provides a variety of other inference mechanisms. (Parser generators
never provide any capability for this; the language engineer has to build it all by herself):
</li>
<ul>
<li><i>Simple Fact Collection:</i> One way to collect information
is <a href="DMSAttributeGrammars.html?Home=LifeAfterParsing">attribute grammars</a>,
which enable easy computation of arbitrary properties of syntax instances
as annotations on the grammar rules themselves
(a <a href="DomainSpecificLanguage.html?Home=LifeAfterParsing">domain-specific language</a>).
This makes it very easy to collect complexity metrics.
A more interesting example is collection of symbol table data. Since scopes
for identifier names tend to follow the program structure, and this
structure is defined by the grammar, there are almost always grammar
rules which define lexical scopes.  So attribute grammars are a nearly
ideal way to collect the symbol table information.
Coupled with the symbol-insertion capability of the symbol table
library, attribute grammars make it relatively easy to build symbol
tables from parse trees. </li>
<br>
<li><i>Control Flow Analysis:</i> To reason about most (especially procedural) languages, one
needs to know the order and under what conditions actions occur.
This requires <a href="http://en.wikipedia.org/wiki/Control-flow_analysis">control flow
analysis</a>.  DMS implements this using a language-engineer specified
attribute grammar analyzer that understands the control flow semantics
of the language syntax, and a library that constructs a control flow
graph graph from information collected by that analyzer.   The
<a href="FlowAnalysis.html#ControlFlowAnalysis?Home=LifeAfterParsing">resulting control flow
information</a> encodes a "flowchart" of the code in a function or
method, including blocks of actions, conditional branches and
exception branches, operations that occur in unspecified ("parallel"/fork-join)
order, and provides information such as dominators and control
dependences. Additional support allows one to structure this control
flow graph into regions, even if the original program is full of
unstructured blocks (e.g., using uncontrolled "goto").  DMS also provides
tools to build <a href="FlowAnalysis.html#CallGraphAnalysis?Home=LifeAfterParsing">call graphs</a>
(even in the face of indirect pointers, as found in C,
and implicitly in OO programs as "objects", which are really just pointers), 
using data flow anlaysis and points-to information, see below).
</li>
<br>
<li><i>Data Flow Analysis:</i> How information flows through the
program is fundamental to understanding.  What is needed is knowledge
about how data flows from one point in the code to another.
DMS provides a variety of support for computing 
<a href="http://en.wikipedia.org/wiki/data-flow_analysis">data flow information,</a>
using built-in iterative solvers operating over the (possibly parallel)
control flow graph, operating on arbitrary domains
(including bit vectors), using identifier access and update
information as determined by another language-engineer specified
attribute grammar. Using these solvers, <a
href="FlowAnalysis.html#DataFlowAnalysis?Home=LifeAfterParsing"> DMS can determine reaching and use-def
chains</a>, and consequently <a href="http://en.wikipedia.org/wiki/Pointer_analysis">points-to
analysis</a>.  DMS has been used to
<a href="FlowAnalysis.html#PointsToAnalysis?Home=LifeAfterParsing">compute global points-to
analysis</a> for very large code bases. Using the explicitly captured
data flow information, it is relatively easy to implement
foward and backward program slice tracing.
</li>
<br>
<li><i>Symbolic Reasoning:</i> More sophisticated analyzers are
useful to reason about code, including method to compute complex consequences
of semantics and various information flows.  At present, DMS provides
<a href="http://en.wikipedia.org/wiki/Abstract_interpretation">abstract
interpretation</a> to compute symbolic range information for values of
variables in terms of other program variables.  We have just recently
added <a href="http://en.wikipedia.org/wiki/Binary_decision_diagram">Binary Decision Diagram</a>
support (and an extension to handle "finite domains") to allow
fast reasoning about complex boolean conditions over discrete choices
(e.g., enums), especially of interest in reasoning about preprocessor conditionals.
 </li>
</ul>
<li><i>Pattern Matching and Transformation Capability:</i> It is useful
to be able to match arbitrary program fragments,
or to generate arbitrary program fragments. 
<a href="DMSRewriteRules.html?Home=LifeAfterParsing">DMS provides a variety of support for this</a>:
<ul>
   <li><i>Surface-syntax pattern matching:</i> DMS does this with <i>surface-sytax</i> patterns,
        in which one writes code fragments in the target notation with placeholders.  DMS can match
        such patterns against ASTs it has parsed, binding placeholders to
        corresponding subtrees. <i>All one has to do to get this capability is define
        a parser to DMS.</i>  The patterns can also rely entirely or partly on custom-code
        tree-traversals.
   </li>
   <br>
   <li><i>Associative/Commutative matching:</i> 
        Patterns can match on associative and commutative operators that are declared in the grammar.
        (No other available program transformation system known to us does this.)
   </li>
   <br>
   <li><i>Pattern-directed code generation:</i> The same patterns be used to generate ASTs
           that instantiate the patterns with pre-supplied subtrees, allowing
           one to build arbitrarily complicated trees fragments easily, and compose
           them into even larger trees.
   </li>
   <br>
   <li><i>Source to source transformations:</i> One can also
         <a href="SimpleDMSDomainExample.html#TransformationRules?Home=LifeAfterParsing">write optimizations
         or transforms on code, using rewrite rules consisting of pattern pairs</a>,
         one pattern for matching and one for replacement when a match is found.
   </li>
   <br>
   <li><i>Cross language translation:</i> Since rewrite rules can use surface syntax of one language in the
match-pattern, and surface syntax of another in the replace-pattern, one can straightforwardly write
<a href="/Products/Services/COBOLMigration.html?Home=LifeAfterParsing">language-to-language transformations.</a>
   </li>
   <br>
   <li><i>Data flow pattern matching:</i> Nearing release, we are adding the ability to match patterns over dataflows,
       enabling a semantic matching capability.  This is extremely useful in recognizing abstract code idioms
       that are scattered about in real implementation code.
       It can recognize variants produced by alternative design choices whose presence
       is only implicit in the code, as well as identifying the specific design choice configuration that enables
       a match.
   </li>
</ul>
</li>
<br>
<li><i>Pretty-Printing:</i> If code transformations are applied to
improve the code, one needs to be able to regenerate
<i>valid</i> source code from the modified representations.
DMS provides this ability
<a href="DMSPrettyPrinters.html?Home=LifeAfterParsing">
in the form of <i>prettyprinting</i> rules</a>,
which specify how the AST should be regenerated in terms
of its original layout ("fidelity printing") or in terms of
nested, indented text boxes ("pretty printing").
These capabilities can be used to show smaller subtrees,
also.  The prettyprinter regenerates accurate numerical (especially
floating point or infinite precision) values, lexical formatting
information, (string quotes, radix, character escape codes, etc.),
as well as comments, preprocessor macro declarations, 
includes, ifdefs and macro calls.
</li>
<br>
<li><i>Multi-module and multi-lingual Integration:</i> Real software
systems are not coded entirely in one language (Java? What, no SQL or HTML?).
As a practical matter to process large <i>systems</i> of code, a good tool
must be able to parse all the sublanguages and tie information
together across the elements. DMS can host multiple language front ends/symbol
tables/flow analyzers/prettyprinters simultaneously.</li>
</ul>

<p><i><b>Bottom line: A parser simply isn't enough to do serious work.
DMS is designed to be enough. The payoff is the ability to build real, useful,
and robust tools with modest resources and time, as opposed to the common tool
failure of "succeeding in just building a parser".</b></i>
</p>

<h2>Bonus: Pretested Language FrontEnds</h2>

<p>DMS has many
<a href="/Products/FrontEnds?Home=LifeAfterParsing">predefined
language front ends</a> which
have been developed and honed over the last decade. These front ends
include grammars, prettyprinters, and to varying degrees, symbol
tables, flow analysis, etc. For real
languages such as COBOL, Java, C# and C++, you are much better off getting
one (or more) of SD's tested language front ends than trying to define
the grammar let alone the full front end yourself,
or attempting to bend another that hasn't been used for serious tasks.
</p>

<h2>Double Bonus: Faster answers through Parallel foundations</h2>

<p>Programs are getting bigger (millions of lines of code), and people
(programmers and their managers) want answers fast.  One way to get
faster answers is to use parallelism.
<i>Cycles are an engineer's best friend.</i><P>

<P>All of the DMS machinery is implemented in a parallel programming language,
<a href="/Products/DMS/ParlanseForDMS.html?Home=LifeAfterParsing">PARLANSE</a>
which is designed to handle multicore irregular ("task") parallel computation.
The DMS implementation provides for thread-safe access and update to all the
structures to enable multiple analyses and transformations to occur.
This allows DMS to scalably process very large systems of code, using
the multiple CPUs available in virtually every desktop workstation that
programmers have.   We have not seen any other parser generator,
program analysis, or program transformation tool that provides this
capability.</P>

<P>It should be obvious that defining a full set of tools
for processing languages is difficult.  Defining such a set with
parallel foundations is something a language engineer would not
consider.  But it is available built into DMS.
</P>

  </div>
 </div>

       <div id="sidebar">
          <div class="block block-series block-list">
           <!-- Show the SD logo on the right stripe -->
           <a href="/index.html"><img border="0" src="/images/SDLogo-nowords.png" width="160" height="58" alt="Semantic Designs, Inc. logo"></a>

           <!-- Show special Contact button on the right stripe -->
          <form name="FreeAssessment" action="FreeConsultation.jsp" method="post">
            <div class="block block-categories">
              <ul>
                <li class="free-consultation">
                  <a class="free-consultation" href="/Contact/FreeConsultation.jsp">
                    Request a Free Migration Consultation
                    </a>
                  </li>
                </ul>
            </div>
          </form>

           <!-- Show free trial-software button on the right stripe -->
	   <!--
          <form name="TrialSoftware" action="FreeTrial.jsp" method="post">
            <div class="block block-categories">
              <ul>
                <li class="free-trial">
                  <a class="free-trial" href="/Contact/FreeTrialSoftware.html">
                    Free Trial Software<br>
                    (New&nbsp;Year&nbsp;Special)
                    </p>
                    </a>
                  </li>
                </ul>
            </div>
          </form>
          -->


          <!-- <div class="download-button" style="width:60px;height:100px;">This is a button</div> -->


            <form name="SDSearch" action="http://www.google.com/search" method="get" onsubmit="SDSiteSearch(this)" id="SDSearch">
              <input id="hiddenquery" type="hidden" name="q"> <input name="qfront" type="text" style="width: 150px" value=""> <input type="submit" value="Search SD"><br>
              <script type="text/javascript">

                                //Enter domain of site to search.
                                var domainroot="www.semanticdesigns.com"
                                function SDSiteSearch(curobj){
                                document.getElementById("hiddenquery").value="site:www.semanticdesigns.com "+curobj.qfront.value
                                }
                                </script>
            </form>



            <div class="block block-categories">
              <h3>Topics</h3>
              <ul id="cats">
                                <li class="cat-reengineering"><a class="cat-reengineering" href="/index.html">Re-engineering</a></li>
                                <li class="cat-documentation"><a class="cat-documentation" href="/index.html">Documentation</a></li>
                                <li class="cat-assessment"><a class="cat-assessment" href= "/index.html">Assessment</a></li>
                                <li class="cat-improvement"><a class="cat-improvement" href="/index.html">Improvement</a></li>
                                <li class="cat-codegen"><a class="cat-codegen" href="/index.html">Code Generation</a></li>
                                <li class="cat-hdl"><a class="cat-hdl" href="/index.html">Hardware Description Languages</a></li>
                                <li class="cat-all"><a class="cat-all" href="/index.html">All Topics</a></li>
              </ul>
            </div>

            <form name="drops" method="post" action="http://semanticdesigns.com" id="drops">
              Language:<br>
              <select name="language" size="1" onchange="changeList(this)">
                <option value="AdaProducts">
                  language
                </option>
              </select><br>
              Product:<br>
              <select name="product" size="1">
                <option>
                  products
                </option>
              </select> <input type="button" onclick="location = ''+document.drops.product.options[document.drops.product.selectedIndex].value;" value="Go!">
            </form>



           </div>

          <h3>Semantic Designs- Our Goal</h3>
          <div id="home-mission">
            To enable our customers to produce and maintain timely, robust and economical software by providing world-class Software Engineering tools using deep language and problem knowledge with high degrees of automation.
          </div>

      </div>

        <div class="push"></div>
        </div> <!--Container-->


      <div class="block-masthead">For more information: <a href="mailto:info@semanticdesigns.com">info@semanticdesigns.com</a>&nbsp;&nbsp;&nbsp;&nbsp;Follow us at Twitter: <a href="http://twitter.com/SemanticDesigns">@SemanticDesigns</a><br>
      <br>
      <div class="copyright" >Copyright 1995-2023 Semantic Designs, Incorporated<br>
      DMS, "Design Maintenance System" and Refactor++ are registered trademarks of Semantic Designs, Inc.<br>
      The SD logo and "Semantic Designs" are registered service marks of Semantic Designs, Inc.<br>
      Software Reengineering Toolkit, CloneDR, PARLANSE, JOVIAL2C, Thicket, Smart Differencer, CheckPointer are trademarks of Semantic Designs, Inc.<br>
      The OMG logo is a registered trademark of the Object Management Group, Inc. in the United States and other countries.<br>
      To view our Privacy Policy, click <a href="/PrivacyPolicy.html">here</a><br>
      <br>
      Comments or problems: <a
      href="mailto:webmaster@semanticdesigns.com">webmaster@semanticdesigns.com</a>
      <font size="-1"><br></font>
      </div>

    </div>





<div class="slogan">
Life<BR>after Parsing
</div>
</body>
</html>
